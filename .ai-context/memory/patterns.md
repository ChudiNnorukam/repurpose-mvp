# Code Patterns & Conventions

**Purpose**: Shared patterns for consistent code generation across Claude and Codex agents
**Last Updated**: October 13, 2025

---

## OAuth Implementation Pattern

**When adding a new OAuth provider, follow this exact pattern:**

### File Structure

```
lib/{platform}.ts                    # OAuth helpers
app/api/auth/{platform}/route.ts     # OAuth initiation
app/api/auth/{platform}/callback/route.ts  # OAuth callback
lib/__tests__/{platform}.test.ts     # Unit tests
```

### Template (from lib/twitter.ts)

```typescript
// lib/{platform}.ts
import crypto from 'crypto'

export interface {Platform}OAuthConfig {
  clientId: string
  clientSecret: string
  redirectUri: string
  scopes: string[]
}

export function generate{Platform}AuthUrl(config: {Platform}OAuthConfig, state: string): string {
  // Implementation
}

export async function get{Platform}AccessToken(code: string, config: {Platform}OAuthConfig): Promise<TokenResponse> {
  // Implementation
}

export async function refresh{Platform}Token(refreshToken: string, config: {Platform}OAuthConfig): Promise<TokenResponse> {
  // Implementation
}

export async function post{Platform}Content(content: string, accessToken: string): Promise<PostResponse> {
  // Implementation
}
```

### Checklist

- [ ] Follow lib/twitter.ts structure exactly
- [ ] Use ErrorResponses for all errors
- [ ] Implement token refresh logic
- [ ] Add JSDoc comments
- [ ] Write tests with 95% coverage
- [ ] Add platform to lib/types.ts `Platform` union

**Reference Implementation**: lib/twitter.ts
**Generated By**: Codex (from Claude spec)
**Last Used**: Instagram OAuth (2025-10-13)

---

## API Route Pattern

**Standard API route with auth, rate limiting, validation:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ErrorResponses } from '@/lib/api/errors'
import { checkRateLimit, apiRateLimiter, getRateLimitIdentifier } from '@/lib/rate-limit'

export async function POST(request: NextRequest) {
  try {
    // 1. Authentication
    const supabase = await createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return ErrorResponses.unauthorized()
    }

    // 2. Rate Limiting
    const identifier = getRateLimitIdentifier(request, user.id)
    const rateLimitResult = await checkRateLimit(apiRateLimiter, identifier)

    if (!rateLimitResult.success) {
      return NextResponse.json(
        {
          error: `Rate limit exceeded. Try again after ${new Date(rateLimitResult.reset).toLocaleTimeString()}.`,
          limit: rateLimitResult.limit,
          remaining: rateLimitResult.remaining,
          reset: rateLimitResult.reset
        },
        { status: 429, headers: rateLimitResult.headers }
      )
    }

    // 3. Parse and validate input
    const body = await request.json()
    // Add validation...

    // 4. Business logic
    // Implementation...

    // 5. Success response
    return NextResponse.json({ success: true, data: result })
  } catch (error: any) {
    console.error('Error in /api/endpoint:', error)
    return ErrorResponses.internalError(error.message)
  }
}
```

**Key Points**:
- Always include auth check first
- Rate limiting second
- Validation third
- Use ErrorResponses for consistency
- Log errors before returning

---

## Database Query Pattern

### Client-Side (with RLS)

```typescript
import { supabase } from '@/lib/supabase/client'

const { data, error } = await supabase
  .from('table_name')
  .select('*')
  .eq('user_id', userId)  // RLS enforces this automatically
  .order('created_at', { ascending: false })

if (error) {
  console.error('Database error:', error)
  // Handle error
}
```

### Server-Side (admin privileges)

```typescript
import { getSupabaseAdmin } from '@/lib/supabase'

const supabaseAdmin = getSupabaseAdmin()
const { data, error } = await supabaseAdmin
  .from('table_name')
  .update({ status: 'updated' })
  .eq('id', recordId)
  .single()

if (error) {
  throw new Error(`Database update failed: ${error.message}`)
}
```

**Key Points**:
- Use client-side supabase for user-scoped queries (RLS)
- Use admin client only when necessary (cross-user operations)
- Always handle errors
- Use .single() when expecting one result

---

## Error Handling Pattern

### Using ErrorResponses

```typescript
import { ErrorResponses, ErrorCode, createErrorResponse } from '@/lib/api/errors'

// Standard errors
return ErrorResponses.unauthorized()
return ErrorResponses.missingField('fieldName')
return ErrorResponses.internalError(error.message)

// Custom errors
return createErrorResponse(
  'Custom error message',
  ErrorCode.CUSTOM_CODE,
  400,
  error.details,
  'fieldName'
)
```

**Error Codes**:
- `UNAUTHORIZED`: 401
- `FORBIDDEN`: 403
- `NOT_FOUND`: 404
- `INVALID_INPUT`: 400
- `RATE_LIMIT_EXCEEDED`: 429
- `OPENAI_ERROR`: 503
- `QSTASH_ERROR`: 500
- `INTERNAL_ERROR`: 500

---

## Testing Pattern

### Unit Test Template

```typescript
import { functionToTest } from '../module'

describe('ModuleName', () => {
  describe('functionToTest', () => {
    it('should handle happy path', () => {
      const result = functionToTest(validInput)
      expect(result).toEqual(expectedOutput)
    })

    it('should handle edge case', () => {
      const result = functionToTest(edgeCaseInput)
      expect(result).toEqual(expectedEdgeOutput)
    })

    it('should throw error on invalid input', () => {
      expect(() => functionToTest(invalidInput)).toThrow('Expected error message')
    })
  })
})
```

### E2E Test Template (Playwright)

```typescript
import { test, expect } from '@playwright/test'

test.describe('Feature Name', () => {
  test('should complete user flow', async ({ page }) => {
    // Setup
    await page.goto('/start-page')

    // Actions
    await page.fill('[name=field]', 'value')
    await page.click('button[type=submit]')

    // Assertions
    await expect(page.locator('.success-message')).toContainText('expected')
  })
})
```

**Key Points**:
- Describe blocks for grouping
- Clear test names (should...)
- Test happy path + edge cases + errors
- 95% coverage minimum for new code

---

## Type Safety Pattern

### Central Type Definitions (lib/types.ts)

```typescript
export type Platform = 'twitter' | 'linkedin' | 'instagram'
export type Tone = 'professional' | 'casual' | 'friendly' | 'authoritative' | 'enthusiastic'
export type PostStatus = 'draft' | 'scheduled' | 'posted' | 'failed'

export interface Post {
  id: string
  user_id: string
  platform: Platform
  original_content: string
  adapted_content: string
  scheduled_time: string | null
  status: PostStatus
  posted_at: string | null
  error_message: string | null
  qstash_message_id: string | null
  created_at: string
  updated_at: string
}
```

**Key Points**:
- Use union types for enums
- Define interfaces for all entities
- Co-locate related types
- Export from central location

---

## Pattern Update Protocol

When establishing a new pattern:

1. Implement in code
2. Document in this file
3. Update active-session.json with reference
4. Cite in future specs

When a pattern changes:

1. Update this file
2. Note in memory/decisions.md as ADR
3. Add migration guide if breaking

---

**Maintained By**: Both Claude and Codex
**Review**: When adding new patterns
**Archive**: Old patterns to patterns-archive.md
